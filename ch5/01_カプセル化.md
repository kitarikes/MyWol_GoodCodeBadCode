# バラバラなデータとロジックをカプセル化する
## int等のプリミティブな値を引数とせず、型を作る

そうすることで、その値に関する条件分岐を色んな場所に散在しなくて済む。

```java
// 値に関するロジックが散在している
class Util {
    boolean isFairPrice(int regularPrice) {
        if (regularPrice < 0) {
            throw new IllegalArgumentException();
        }
    }

    int discountedPrice(int regularPrice, float discountRate) {
        if (regularPrice < 0) {
            throw new IllegalArgumentException();
        }
        if (discountRate < 0.0f) {
            throw new IllegalArgumentException();
        }
    }
}
```

```java
// 型として存在する限り、正常な値が入っていることが保証されるため、if文を都度書く必要がない
class RegularPrice {
    final int amount;

    RegularPrice(final int amount) {
        if (amount < 0) {
            throw new IllegalArgumentException();
        }
        this.amount = amount;
    }
}
```

## staticメソッドを誤用しない

staticメソッドはインスタンスを生成しなくても使えるメソッド。そのため、データとロジックがバラバラになる可能性がある。

## 生成ロジックを分散しない

コンストラクタを公開すると、多様な初期化ロジックが、色々な場所で記述される可能性がある。

```java
GiftPoint standardMemberShipPoint = new GiftPoint(3000);
GiftPoint premiumMemberShipPoint = new GiftPoint(10000);
```

↓ 生成ロジックが増える&使い回しそうな時は、コンストラクタをprivateにする

**ファクトリクラス！**：このように、コンストラクタを公開せず、初期化するメソッドをstaticで公開する設計もある。

```java
class GiftPoint {
    private static final int MIN_POINT = 0;
    private static final int STANDARD_MEMBERSHIP_POINT = 3000;
    private static final int PREMIUM_MEMBERSHIP_POINT = 10000;
    final int value;

    // 外部からはインスタンス生成できない。
    // クラス内部でのみインスタンス生成できる。
    private GiftPoint(final int point) {
        if (point < MIN_POINT) {
            // throw ~~
        }
        value = point;
    }
}

static GiftPoint forStandardMembership() {
    return new GiftPoint(STANDARD_MEMBERSHIP_POINT);
}

// ・・・
```